# Indigo4L
# SC1721


#^ 2024.11.13

#^ Component ID : SAD_DRI_109  
#^ Internal Flash Address : 
#^ RAM : 
#^ 전달 인자(GPreg)를 받을 RAM 주소 : 
#^ 반환 인자(GPreg)에 전달할 RAM 주소 : 

#^ UNIT 
#^ 1. Flt_Ctrl 
#^ 2. Flt_OUT


###################################################################################################################
###################################################################################################################
###################################################################################################################
## Comp - SAD_DRI_109 FLT_Handler (Fault Handler)
## Unit - Flt_Ctrl (Fault Control)
#@ caller - "SAD_RTC_303 Event1" 

fncBegin        #name:Flt_Ctrl# , Fault_Control 

#? 241114 - 
#? 제어기가 Ext Flash에 New FW를 쓰고 있다면, Indigo는 Fault log가 불가능함
#? 여기에 대한 예외 처리 필요. SAD_DRI_109에 input이 없는데, 점유 여부에 대한 변수 설정 가능. 
#? 만약 Ext 접근 못 하는 시간동안 Int에만 Fault log해도 문제. 계속 Fault가 바뀐다면? 
#? 즉, 제어기가 New FW Writing 도중에는 Fault log를 못 하게 하는 낫다고 봄. 

#% COMP 전달인자 (caller "SAD_RTC_303 Event1" - callee SAD_DRI_202)
r32 0x00040200
i4drput 32  0x600025F8          # Occupied_ExtFlash = GPreg[0]

## ExtFlash Check 
i4drcheck   0x0000FFFF          # 
    jmpnamed    always  0       #name:NOT_OCCUPIED# 
    jmpnamed    always  0       #name:HOST_OCCUPYING_ExtFlash# - Exit 

lblnamed        #name:NOT_OCCUPIED# 
#% COMP 전달인자 - 없음 
#@ Comp Call 
fncCall         #name:Flt_Hex2Bit#  
#% COMP 반환인자 - 
r32 0x0004027C  # GPreg[31], Current_Fault_Result
i4drsave    0   # Buffer[0] = Current_Fault_Result 

r32 0x60001FF8  # Past_Fault_Result
i4drsave    1   # Buffer[1] = Past_Fault_Result 

#% UNIT 전달인자 - Buffer[0,1]
#@ Unit Call 
fncCall         #name:Flt_OUT# 
#% UNIT 반환인자 - 없음. 

lblnamed        #name:HOST_OCCUPYING_ExtFlash# 

fncEnd          #name:Flt_Ctrl# , Fault_Control 



###################################################################################################################
###################################################################################################################
###################################################################################################################
## Comp - SAD_DRI_109 FLT_Handler (Fault Handler)
## Unit - Flt_OUT (Fault Out)
#@ caller - "Flt_Ctrl"

#! Fault가 발생하면 Low 유지. Fault가 사라지면 High로 변경. 즉, 하나의 Fault라도 계속 유지 되면, SYS_FAULT pin은 Low를 유지한다. 
#! 단, Fault가 사라져도 Log는 남겨야 함. 

#$ SCH net name : SYS_FAULT[GPIO59] (OK - High, Fault - Low)

#% UNIT 전달인자 
#% Buffer[0]    Current_Fault_Result    0x60001FFC 
#% Buffer[1]    Past_Fault_Result       0x60001FF8    

fncBegin        #name:Flt_OUT#

## Fault occurence check 
i4drrestore 0                   # DREG0 = Current_Fault_Result
i4drcheck 0x00000000
    jmpnamed    always  0       #name:FAULT_OCCURED#   
    jmpnamed    always  0       #name:FAULT_NOT_OCCURED# 

## Fault Occured
lblnamed                        #name:FAULT_OCCURED# 

# 1. Compare - past & current 
i4drrestore 0                   # DREG1 = DREG0, DREG0 = Current_Fault_Result 
i4drrestore 1                   # DREG1 = Current_Fault_Result, DREG0 = Past_Fault_Result 
jmpnamed    !=  0               #name:NEW_FAULT_OCCURED#    
jmpnamed    always  0           #name:NEW_FAULT_NOT_OCCURED# 

# 2. Write Fault data into Int&Ext Flash, if new Fault occured 
lblnamed                        #name:NEW_FAULT_OCCURED# 

#% COMP 전달인자 
#? <- 전달인자 추가 정리할 것. 
#@ Comp Call 
i4call          # Status Save   #? 수정할 것.  
#% COMP 반환인자 - 없음. 

# 3. SYS_FAULT_PIN low  
lblnamed                        #name:NEW_FAULT_NOT_OCCURED# 
wf32    0x000A800C  27  1   1   # POCR0 High : Low, Fault occured - SYS_FAULT pin low 
jmpnamed    always  0           #name:Flt_OUT_END# 

## FAULT not occured 
lblnamed                        #name:FAULT_NOT_OCCURED# 
wf32    0x000A8004  27  1   1   # POSR0 High : High, Fault not occured - SYS_FAULT pin high

lblnamed                        #name:Flt_OUT_END# 
fncEnd          #name:Flt_OUT#

